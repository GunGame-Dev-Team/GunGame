// Endmap command and event v2.05
// by cagemonkey
//
// Requires ES v1.5+
//   uses corelib score command in round_end
//
// Ends the current map and fires a map_end event
// Any other script can use the map_end event just like any other normal event
//
// Command:
//  endmap [nextmap] [now]
//    now and <nextmap> are optional.
//
//  now - ends the map now. Without this, the map ends when the current round is over.
//  <nextmap> - name of the map to change to next.

block load
{
	refcount increment eventscripts_maphandler 1
	
	es_xloadevents declare addons/eventscripts/event_map_end/es_event_map_end.res
	
	//Init vars
	es_xset eme_starttime 0
	es_xset eme_currenttime 0
	es_xset eme_timeleft 0
	es_xset eme_t_score 0
	es_xset eme_ct_score 0
	es_xset eme_userid 0
	es_xset eme_roundend 0
	es_xset eme_roundcount 0
	es_xset eme_user_score 0
	es_xset eme_players 0
	es_xset eme_exists 0
	es_xset eme_check 0
	es_xset eme_tmp 0
	
	//Create console command
	es_xexists eme_exists command endmap
	ifx false(eme_exists) do
	{
		es_xregcmd endmap event_map_end/end_map "Ends the current map and optionally sets nextmap, Syntax: endmap [mapname] [now]"
	}
	
	//Create poweruser say command
	clientcmd create say endmap "event_map_end/end_map" "endmap" #poweruser
}

event es_map_start
{
	es_loadevents addons/eventscripts/event_map_end/es_event_map_end.res
	
	//Setup variables
	es_xset eme_roundend 0
	es_xset eme_t_score 0
	es_xset eme_ct_score 0
	es_xgettime eme_starttime
	es_xset eme_currenttime 0
	es_xset eme_roundcount 0
	es_xset eme_check 0
	es_xmathparse eme_timeleft "mp_timelimit * 60"
}

event server_cvar
{
	if (event_var(cvarname) == mp_winlimit) do
	{
		score get eme_ct_score #ct
		score get eme_t_score #t
		if (event_var(cvarvalue) < server_var(eme_ct_score)) do
		{
			ifx false(eme_check) do
			{
				//Trigger map_end
				es_xevent initialize map_end
				es_xevent setint map_end reason 6   // Other
				es_xevent fire map_end
				es_xset eme_check 1
			}
		}
		if (event_var(cvarvalue) < server_var(eme_t_score)) do
		{
			ifx false(eme_check) do
			{
				//Trigger map_end
				es_xevent initialize map_end
				es_xevent setint map_end reason 6   // Other
				es_xevent fire map_end
				es_xset eme_check 1
			}
		}
	}
	
	if (event_var(cvarname) == mp_maxrounds) do
	{
		if (event_var(cvarvalue) < server_var(eme_roundcount)) do
		{
			ifx false(eme_check) do
			{
				//Trigger map_end
				es_xevent initialize map_end
				es_xevent setint map_end reason 6   // Other
				es_xevent fire map_end
				es_xset eme_check 1
			}
		}
	}
	
	if (event_var(cvarname) == mp_fraglimit) do
	{
		foreach player eme_userid #all "es_xdoblock event_map_end/frag_check"
	}
}

event round_start
{
	// Check for mp_maxrounds
	ifx true(mp_maxrounds) do
	{
		if (server_var(eme_roundcount) == server_var(mp_maxrounds)) do
		{
			ifx false(eme_check) do
			{
				//Trigger map_end
				es_xevent initialize map_end
				es_xevent setint map_end reason 6   // Other
				es_xevent fire map_end
				es_xset eme_check 1
			}
		}
	}
	
	// Does not meet mp_maxrounds, so continue...
	ifx true(eme_reset) do
	{
		//Setup counters
		es_xset eme_t_score 0
		es_xset eme_ct_score 0
		es_xgettime eme_starttime
		es_xset eme_currenttime 0
		es_xset eme_roundcount 0
		es_xmathparse eme_timeleft "mp_timelimit * 60"
	}
	es_xset eme_reset 1
}

event round_end
{
	es_xset eme_reset 0
	es_xmath eme_roundcount + 1
	
	//If game is commencing, reset counters on round_start
	if (event_var(reason) == 16) do
	{
		es_xset eme_reset 1
	}

	//Get timeleft
	ifx true(mp_timelimit) do
	{
		es_xgettime eme_currenttime
		es_xmathparse eme_timeleft "mp_timelimit * 60 + eme_starttime - eme_currenttime"
	}
	else do
	{
		es_xset eme_timeleft 1
	}
	if (server_var(eme_timeleft) <= 0) do
	{
		ifx false(eme_check) do
		{
			//Trigger map_end
			es_xevent initialize map_end
			es_xevent setint map_end reason 1   // Timeout
			es_xevent fire map_end
			es_xset eme_check 1
		}
	}
	else do
	{
		//Get scores
		ifx true(mp_winlimit) do
		{
			score get eme_ct_score #ct
			score get eme_t_score #t

			if (server_var(eme_ct_score) == server_var(mp_winlimit)) do
			{
				ifx false(eme_check) do
				{
					//Trigger map_end
					es_xevent initialize map_end
					es_xevent setint map_end reason 3   // CT win
					es_xevent fire map_end
					es_xset eme_check 1
				}
			}
			if (server_var(eme_t_score) == server_var(mp_winlimit)) do
			{
				ifx false(eme_check) do
				{
					//Trigger map_end
					es_xevent initialize map_end
					es_xevent setint map_end reason 4   // T win
					es_xevent fire map_end
					es_xset eme_check 1
				}
			}
		}
	}
	ifx true(eme_roundend) do
	{
		ifx false(eme_check) do
		{
			//Trigger map_end
			es_xevent initialize map_end
			es_xevent setint map_end reason 5   // Commanded
			es_xevent fire map_end
			es_xset eme_check 1
	
			//Fire game_end
			es_xgetplayercount eme_players
			if (server_var(eme_players) == 0) do
			{
				es_xcreatebot eme_userid Endmap
			}
			else do
			{
				es_xgetuserid eme_userid
			}
			es_give server_var(eme_userid) game_end
			es_fire server_var(eme_userid) game_end EndGame
		}
	}
	
	// Check for mp_fraglimit
	ifx true(mp_fraglimit) do
	{
		foreach player eme_userid #all "es_xdoblock event_map_end/frag_check"
	}
}

block frag_check
{
	es score get eme_user_score server_var(eme_userid)
	if (server_var(eme_user_score) >= server_var(mp_fraglimit)) do
	{
		ifx false(eme_check) do
		{
			//Trigger map_end
			es_xevent initialize map_end
			es_xevent setint map_end reason 2   // Frag limit
			es_xevent fire map_end
			es_xset eme_check 1
		}
	}
}

block end_map
{
	es_xset eme_args 0
	es_xset eme_arg1 0
	es_xset eme_arg2 0
	
	es_xgetargs eme_args
	if (server_var(eme_args) != 0) do
	{
		es_xgetargv eme_arg1 1
		es_xgetargv eme_arg2 2
		
		if (server_var(eme_arg1) == "now") do
		{
			ifx false(eme_check) do
			{
				if (server_var(eme_arg2) != 0) do
				{
					es eventscripts_nextmapoverride server_var(eme_arg2)
				}
				
				//Trigger map_end
				es_xevent initialize map_end
				es_xevent setint map_end reason 5   // Commanded
				es_xevent fire map_end
				es_xset eme_check 1
	
				//Fire game_end
				es_xgetplayercount eme_players
				if (server_var(eme_players) == 0) do
				{
					es_xcreatebot eme_userid Endmap
				}
				else do
				{
					es_xgetuserid eme_userid
				}
				es_give server_var(eme_userid) game_end
				es_fire server_var(eme_userid) game_end EndGame
				es_xmathparse eme_tmp "mp_chattime + 3"
				es_delay server_var(eme_tmp) changelevel de_dust
			}
		}
		else do
		{
			if (server_var(eme_arg1) == "gettimeleft") do
			{
				//Get the timeleft
				es_xgettime eme_currenttime
				es_xmathparse eme_timeleft "mp_timelimit * 60 + eme_starttime - eme_currenttime"
				es_set server_var(eme_arg2) server_var(eme_timeleft)
			}
			else do
			{
				es eventscripts_nextmapoverride server_var(eme_arg1)
				
				if (server_var(eme_arg2) == "now") do
				{
					ifx false(eme_check) do
					{
						//Trigger map_end
						es_xevent initialize map_end
						es_xevent setint map_end reason 5   // Commanded
						es_xevent fire map_end
  					es_xset eme_check 1
  
 	 					//Fire game_end
  					es_xgetplayercount eme_players
  					if (server_var(eme_players) == 0) do
  					{
	  					es_xcreatebot eme_userid Endmap
  					}
  					else do
  					{
	  					es_xgetuserid eme_userid
  					}
  					es_give server_var(eme_userid) game_end
  					es_fire server_var(eme_userid) game_end EndGame
  					es_xmathparse eme_tmp "mp_chattime + 3"
						es_delay server_var(eme_tmp) changelevel de_dust
  				}
  			}
  			else do
  			{
  				es_xset eme_roundend 1
  			}
  		}
		}
	}
	else do
	{
		es_xset eme_roundend 1
	}
}

event map_end
{
	es_log Map has ended for reason code event_var(reason)
}

block unload
{
	refcount decrement eventscripts_maphandler 1
}